"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const axios_1 = __importDefault(require("axios"));
const qs_1 = require("qs");
const RPCError_1 = require("./Errors/RPCError");
const ErrorResponse_1 = require("./Abstracts/ErrorResponse");
exports.ErrorResponse = ErrorResponse_1.ErrorResponse;
class Client {
    constructor(config) {
        config = {
            headers: {
                'Content-Type': 'application/json'
            },
            ...config,
            ...{ paramsSerializer: qs_1.stringify }
        };
        if (config.baseURL) {
            let parsedUrl = new URL(config.baseURL);
            if (parsedUrl.username) {
                let credentials = {
                    username: parsedUrl.username,
                    password: parsedUrl.password,
                };
                delete parsedUrl.username;
                delete parsedUrl.password;
                config['auth'] = credentials;
                config['baseURL'] = parsedUrl.href;
            }
        }
        this.axios = axios_1.default.create(config);
    }
    mappingResponse(res, multiple = false) {
        if (res instanceof Array) {
            return res.map((item) => {
                return this.mappingResponse(item, true);
            });
        }
        if (res.error) {
            if (!multiple) {
                throw new RPCError_1.RPCError(res.error, res.error.message || 'RPC Error', res.error.code || -32003);
            }
            else {
                return new ErrorResponse_1.ErrorResponse(res.error);
            }
        }
        return res.result;
    }
    ;
    async request(url, params) {
        return this.axios
            .post(url, params || this.defaultParams, {})
            .then(response => (response ? response.data : response))
            .catch((err) => {
            if (err.response && err.response.data) {
                return this.mappingResponse(err.response.data);
            }
            throw err;
        });
    }
    rpc(...args) {
        let data = args.flat(Infinity)
            .map((item, i) => {
            return {
                id: ++i,
                jsonrpc: '2.0',
                ...item,
            };
        });
        if (data.length === 1) {
            data = data[0];
        }
        return this
            .request('', data)
            .then(this.mappingResponse.bind(this))
            .then((data) => data);
    }
}
exports.Client = Client;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvQ2xpZW50L2luZGV4LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsa0RBQTBGO0FBQzFGLDJCQUFpRDtBQUNqRCxnREFBMkM7QUFHM0MsNkRBQXdEO0FBT2hELHdCQVBBLDZCQUFhLENBT0E7QUFFckIsTUFBYSxNQUFNO0lBSWYsWUFBWSxNQUFxQjtRQUM3QixNQUFNLEdBQUc7WUFDTCxPQUFPLEVBQUU7Z0JBQ0wsY0FBYyxFQUFFLGtCQUFrQjthQUNyQztZQUNELEdBQUcsTUFBTTtZQUNULEdBQUcsRUFBQyxnQkFBZ0IsRUFBaEIsY0FBZ0IsRUFBQztTQUN4QixDQUFDO1FBRUYsSUFBSSxNQUFNLENBQUMsT0FBTyxFQUFFO1lBQ2hCLElBQUksU0FBUyxHQUFHLElBQUksR0FBRyxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsQ0FBQztZQUN4QyxJQUFJLFNBQVMsQ0FBQyxRQUFRLEVBQUU7Z0JBQ3BCLElBQUksV0FBVyxHQUFHO29CQUNkLFFBQVEsRUFBRSxTQUFTLENBQUMsUUFBUTtvQkFDNUIsUUFBUSxFQUFFLFNBQVMsQ0FBQyxRQUFRO2lCQUMvQixDQUFDO2dCQUNGLE9BQU8sU0FBUyxDQUFDLFFBQVEsQ0FBQztnQkFDMUIsT0FBTyxTQUFTLENBQUMsUUFBUSxDQUFDO2dCQUMxQixNQUFNLENBQUMsTUFBTSxDQUFDLEdBQUcsV0FBVyxDQUFDO2dCQUM3QixNQUFNLENBQUMsU0FBUyxDQUFDLEdBQUcsU0FBUyxDQUFDLElBQUksQ0FBQzthQUN0QztTQUNKO1FBQ0QsSUFBSSxDQUFDLEtBQUssR0FBRyxlQUFLLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBQ3RDLENBQUM7SUFHRCxlQUFlLENBQUMsR0FBZ0IsRUFBRSxXQUFvQixLQUFLO1FBQ3ZELElBQUksR0FBRyxZQUFZLEtBQUssRUFBRTtZQUN0QixPQUFPLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFtQixFQUFFLEVBQUU7Z0JBQ25DLE9BQU8sSUFBSSxDQUFDLGVBQWUsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLENBQUM7WUFDNUMsQ0FBQyxDQUF5QixDQUFDO1NBQzlCO1FBQ0QsSUFBSSxHQUFHLENBQUMsS0FBSyxFQUFFO1lBQ1gsSUFBSSxDQUFDLFFBQVEsRUFBRTtnQkFDWCxNQUFNLElBQUksbUJBQVEsQ0FBQyxHQUFHLENBQUMsS0FBSyxFQUFFLEdBQUcsQ0FBQyxLQUFLLENBQUMsT0FBTyxJQUFJLFdBQVcsRUFBRSxHQUFHLENBQUMsS0FBSyxDQUFDLElBQUksSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO2FBQzdGO2lCQUFNO2dCQUNILE9BQU8sSUFBSSw2QkFBYSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQzthQUN2QztTQUNKO1FBQ0QsT0FBTyxHQUFHLENBQUMsTUFBTSxDQUFDO0lBQ3RCLENBQUM7SUFBQSxDQUFDO0lBR0YsS0FBSyxDQUFDLE9BQU8sQ0FBQyxHQUFHLEVBQUUsTUFBTTtRQUNyQixPQUFPLElBQUksQ0FBQyxLQUFLO2FBQ1osSUFBSSxDQUFDLEdBQUcsRUFBRSxNQUFNLElBQUksSUFBSSxDQUFDLGFBQWEsRUFBRSxFQUFFLENBQUM7YUFDM0MsSUFBSSxDQUFDLFFBQVEsQ0FBQyxFQUFFLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxDQUFDO2FBQ3ZELEtBQUssQ0FBQyxDQUFDLEdBQWUsRUFBRSxFQUFFO1lBQ3ZCLElBQUksR0FBRyxDQUFDLFFBQVEsSUFBSSxHQUFHLENBQUMsUUFBUSxDQUFDLElBQUksRUFBRTtnQkFDbkMsT0FBTyxJQUFJLENBQUMsZUFBZSxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUM7YUFDbEQ7WUFDRCxNQUFNLEdBQUcsQ0FBQztRQUNkLENBQUMsQ0FBQyxDQUFDO0lBQ1gsQ0FBQztJQUtELEdBQUcsQ0FBSSxHQUFHLElBQXVDO1FBQzdDLElBQUksSUFBSSxHQUFvQyxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQzthQUMxRCxHQUFHLENBQUMsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxFQUFFLEVBQUU7WUFDYixPQUFPO2dCQUNILEVBQUUsRUFBRSxFQUFFLENBQUM7Z0JBQ1AsT0FBTyxFQUFFLEtBQUs7Z0JBQ2QsR0FBRyxJQUFJO2FBQ1YsQ0FBQztRQUNOLENBQUMsQ0FBQyxDQUFDO1FBRVAsSUFBSSxJQUFJLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTtZQUNuQixJQUFJLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO1NBQ2xCO1FBRUQsT0FBTyxJQUFJO2FBQ04sT0FBTyxDQUFDLEVBQUUsRUFBRSxJQUFJLENBQUM7YUFDakIsSUFBSSxDQUFDLElBQUksQ0FBQyxlQUFlLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO2FBQ3JDLElBQUksQ0FBQyxDQUFDLElBQVMsRUFBRSxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDbkMsQ0FBQztDQUNKO0FBakZELHdCQWlGQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBBeGlvcywge0F4aW9zRXJyb3IsIEF4aW9zSW5zdGFuY2UsIEF4aW9zUmVxdWVzdENvbmZpZywgQXhpb3NSZXNwb25zZX0gZnJvbSBcImF4aW9zXCI7XG5pbXBvcnQge3N0cmluZ2lmeSBhcyBwYXJhbXNTZXJpYWxpemVyfSBmcm9tICdxcyc7XG5pbXBvcnQge1JQQ0Vycm9yfSBmcm9tIFwiLi9FcnJvcnMvUlBDRXJyb3JcIjtcbmltcG9ydCB7UlBDfSBmcm9tIFwiLi4vQHR5cGVzL3R5cGVzXCI7XG5pbXBvcnQgUmVzcG9uc2UgPSBSUEMuUmVzcG9uc2U7XG5pbXBvcnQge0Vycm9yUmVzcG9uc2V9IGZyb20gXCIuL0Fic3RyYWN0cy9FcnJvclJlc3BvbnNlXCI7XG5cbmV4cG9ydCB0eXBlIENsaWVudE9wdGlvbnMgPSBBeGlvc1JlcXVlc3RDb25maWc7XG5cbnR5cGUgcnBjUmV0dXJuVHlwZSA9IFJlc3BvbnNlIHwgRXJyb3IgO1xuXG5cbmV4cG9ydCB7RXJyb3JSZXNwb25zZX07XG5cbmV4cG9ydCBjbGFzcyBDbGllbnQge1xuICAgIGF4aW9zOiBBeGlvc0luc3RhbmNlO1xuICAgIGRlZmF1bHRQYXJhbXM6IFtdO1xuXG4gICAgY29uc3RydWN0b3IoY29uZmlnOiBDbGllbnRPcHRpb25zKSB7XG4gICAgICAgIGNvbmZpZyA9IHtcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLi4uY29uZmlnLFxuICAgICAgICAgICAgLi4ue3BhcmFtc1NlcmlhbGl6ZXJ9XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGNvbmZpZy5iYXNlVVJMKSB7XG4gICAgICAgICAgICBsZXQgcGFyc2VkVXJsID0gbmV3IFVSTChjb25maWcuYmFzZVVSTCk7XG4gICAgICAgICAgICBpZiAocGFyc2VkVXJsLnVzZXJuYW1lKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNyZWRlbnRpYWxzID0ge1xuICAgICAgICAgICAgICAgICAgICB1c2VybmFtZTogcGFyc2VkVXJsLnVzZXJuYW1lLFxuICAgICAgICAgICAgICAgICAgICBwYXNzd29yZDogcGFyc2VkVXJsLnBhc3N3b3JkLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgZGVsZXRlIHBhcnNlZFVybC51c2VybmFtZTtcbiAgICAgICAgICAgICAgICBkZWxldGUgcGFyc2VkVXJsLnBhc3N3b3JkO1xuICAgICAgICAgICAgICAgIGNvbmZpZ1snYXV0aCddID0gY3JlZGVudGlhbHM7XG4gICAgICAgICAgICAgICAgY29uZmlnWydiYXNlVVJMJ10gPSBwYXJzZWRVcmwuaHJlZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmF4aW9zID0gQXhpb3MuY3JlYXRlKGNvbmZpZyk7XG4gICAgfVxuXG5cbiAgICBtYXBwaW5nUmVzcG9uc2UocmVzOiBhbnkgfCBhbnlbXSwgbXVsdGlwbGU6IGJvb2xlYW4gPSBmYWxzZSk6IHJwY1JldHVyblR5cGUgfCBycGNSZXR1cm5UeXBlW10gfCBFcnJvclJlc3BvbnNlIHtcbiAgICAgICAgaWYgKHJlcyBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzLm1hcCgoaXRlbTogQXhpb3NSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm1hcHBpbmdSZXNwb25zZShpdGVtLCB0cnVlKTtcbiAgICAgICAgICAgIH0pIGFzIFJlc3BvbnNlW10gfCBFcnJvcltdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXMuZXJyb3IpIHtcbiAgICAgICAgICAgIGlmICghbXVsdGlwbGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUlBDRXJyb3IocmVzLmVycm9yLCByZXMuZXJyb3IubWVzc2FnZSB8fCAnUlBDIEVycm9yJywgcmVzLmVycm9yLmNvZGUgfHwgLTMyMDAzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBFcnJvclJlc3BvbnNlKHJlcy5lcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gICAgfTtcblxuXG4gICAgYXN5bmMgcmVxdWVzdCh1cmwsIHBhcmFtcyk6IFByb21pc2U8QXhpb3NSZXNwb25zZSB8IEF4aW9zUmVzcG9uc2VbXT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5heGlvc1xuICAgICAgICAgICAgLnBvc3QodXJsLCBwYXJhbXMgfHwgdGhpcy5kZWZhdWx0UGFyYW1zLCB7fSlcbiAgICAgICAgICAgIC50aGVuKHJlc3BvbnNlID0+IChyZXNwb25zZSA/IHJlc3BvbnNlLmRhdGEgOiByZXNwb25zZSkpXG4gICAgICAgICAgICAuY2F0Y2goKGVycjogQXhpb3NFcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlcnIucmVzcG9uc2UgJiYgZXJyLnJlc3BvbnNlLmRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubWFwcGluZ1Jlc3BvbnNlKGVyci5yZXNwb25zZS5kYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcnBjPFQ+KGFyZ3M6IFJQQy5JUGF5bG9hZCk6IFByb21pc2U8VD47XG4gICAgcnBjPFQ+KGFyZzE6IFJQQy5JUGF5bG9hZCwgLi4uYXJnczogUlBDLklQYXlsb2FkW10pOiBQcm9taXNlPFRbXT47XG4gICAgcnBjPFQ+KGFyZ3M6IFJQQy5JUGF5bG9hZFtdKTogUHJvbWlzZTxUPjtcbiAgICBycGM8VD4oLi4uYXJnczogKFJQQy5JUGF5bG9hZCB8IFJQQy5JUGF5bG9hZFtdKVtdKTogUHJvbWlzZTxUPiB7XG4gICAgICAgIGxldCBkYXRhOiAoUlBDLklQYXlsb2FkIHwgUlBDLklQYXlsb2FkW10pID0gYXJncy5mbGF0KEluZmluaXR5KVxuICAgICAgICAgICAgLm1hcCgoaXRlbSwgaSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiArK2ksXG4gICAgICAgICAgICAgICAgICAgIGpzb25ycGM6ICcyLjAnLFxuICAgICAgICAgICAgICAgICAgICAuLi5pdGVtLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICBpZiAoZGF0YS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIGRhdGEgPSBkYXRhWzBdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgICAgICAgIC5yZXF1ZXN0KCcnLCBkYXRhKVxuICAgICAgICAgICAgLnRoZW4odGhpcy5tYXBwaW5nUmVzcG9uc2UuYmluZCh0aGlzKSlcbiAgICAgICAgICAgIC50aGVuKChkYXRhOiBhbnkpID0+IGRhdGEpO1xuICAgIH1cbn0iXX0=